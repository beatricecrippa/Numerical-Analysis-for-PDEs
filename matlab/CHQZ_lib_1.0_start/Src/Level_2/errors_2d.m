function [err_inf,err_h1,err_l2]=errors_2d(x,wx,dx,xx,jacx,y,wy,dy,yy,jacy,...
xy,ww,nov,un,uex,uex_x,uex_y,param)
% ERRORS_2D Computes errors for 2D b.v.p.
%
% Input:
%        x = npdx LGL nodes in [-1,1], previously generated by xwlgl
%        wx = npdx LGL weigths in [-1,1], previously generated by xwlgl
%        dx = LGL 1-st derivative matrix previously generated by derlgl
%        xx = 2-indexes array of size (4,ne) 
%            xx(1:4,ie)=[x_V1_ie;x_V2_ie;x_V3_ie;x_V4_ie]
%            (ne=nex*ney is the global number of spectral elements)
%        jacx = array (length(jacx)=ne); jacx(ie)= (x_V2_ie-x_V1_ie)/2
%        y = npdx LGL nodes in [-1,1], previously generated by xwlgl
%        wy = npdx LGL weigths in [-1,1], previously generated by xwlgl
%        dy = LGL 1-st derivative matrix previously generated by derlgl
%        yy = 2-indexes array of size (4,ne)
%            yy(1:4,ie)=[y_V1_ie;y_V2_ie;y_V3_ie;y_V4_ie]
%            (ne=nex*ney is the global number of spectral elements)
%        jacy = array (length(jacy)=ne); jacy(ie)= (y_V3_ie-y_V1_ie)/2
%         xy = column array with global mesh, length: noe=nov(npdx*npdy,ne)
%         ww = column array with global weigths, length: noe=nov(npdx*npdy,ne)
%              diag(ww) is the mass matrix associated to SEM discretization
%        nov = local -global map, previously generated by cosnov_2d
%        un = numerical solution
%        uex  = exact solution (uex=@(x,y)[uex(x,y)], with .*, .^, ./)
%        uex_x  = exact first x-derivative (uex_x=@(x,y)[uex_x(x,y)], with .*, .^, ./)
%        uex_y  = exact first y-derivative (uex_y=@(x,y)[uex_y(x,y)], with .*, .^, ./)
%        param(4) = 1: compute errors (L^inf-norm, L2-norm, H1-norm) 
%                      on the exact solution
%                   2: no  errors are computed
%        param(5) = 0: LG quadrature formulas with high precision degree are
%                      used to compute norms (exact norms)
%                   1: LGL quadrature formulas with npdx,npdy nodes are
%                      used to compute norms (discrete norms)
%                   (used only if param(4) == 1)
%        param(6) = number of nodes for high degree quadrature formula,
%                   (used only if param(5) == 0 & param(4) == 1)
%        param(7) = 0: absolute errors are computed
%                   1: relative errors are computed
%                   (used only if param(4) == 1)
%
% Output: 
% 
%         err_inf = ||u_ex-u_N|| with respect to discrete maximum-norm
%         err_h1 = ||u_ex-u_N|| with respect to discrete H1-norm
%         err_l2 = ||u_ex-u_N|| with respect to discrete L2-norm
%
% Reference: CHQZ2 = C. Canuto, M.Y. Hussaini, A. Quarteroni, T.A. Zang,
%                    "Spectral Methods. Fundamentals in Single Domains"
%                    Springer Verlag, Berlin Heidelberg New York, 2006.

%   Written by Paola Gervasio
%   $Date: 2007/04/01$

fdq=param(5); 
if fdq ==0
nq=param(6);
else 
nq=length(wx);
end
errtype=param(7);

% compute errors on the exact solution

npdx=length(wx); npdy=length(wy);
[ldnov,ne]=size(nov);
noe=length(un);

% Evaluate exact solution

u=zeros(noe,1)+uex(xy(:,1),xy(:,2));

%  compute difference

err=u-un;

% ||u_ex-u_N|| with respect to discrete maximum-norm

err_inf=norm(err,inf);
if errtype~=0
    err_inf=err_inf/norm(u,inf);
end
% ||u_ex-u_N|| with respect to H1 norm

% fdq=0 LG quadrature formula with nq nodes on each element
% fdq=1 LGL quadrature formula with npdx nodes on each element

[err_h1]=normah1_2d(fdq,nq,errtype,x,wx,dx,xx,jacx,y,wy,dy,yy,jacy,...
xy,ww,nov,un,u,uex,uex_x,uex_y);

% ||u_ex-u_N|| with respect to L2 norm

[err_l2]=normal2_2d(fdq,nq,errtype,x,wx,xx,jacx,y,wy,yy,jacy,...
xy,ww,nov,un,u,uex);

return
