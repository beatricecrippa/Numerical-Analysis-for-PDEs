function [err_h1]=normah1_2d(fdq,nq,errtype,x,wx,dx,xx,jacx,y,wy,dy,yy,jacy,...
xy,ww,nov,un,u,uex,uex_x,uex_y);
% NORMAH1_2D   Computes H1-norm in 2D
%
%  [err_h1]=normah1_2d(fdq,nq,errtype,x,wx,dx,xx,jacx,y,wy,dy,yy,jacy,...
%            xy,ww,nov,un,u,uex,uex_x,uex_y);
%
% Input : fdq = 0  uses Legendre Gauss quadrature formulas with nq nodes
%               in each element (exactness degree = 2*nq+1)
%             = 1  uses Legendre Gauss Lobatto quadrature formulas with npdx/y
%                  quadrature nodes in each element. 
%                Quadrature nodes are the nodes of the mesh. 
%         nq = nodes (in each element and along each direction) 
%              for GL quadrature formulas. Not used if  fdq == 1
%         errtype = 0 for absolute error ||u-u_ex||
%                   1 for relative error ||u-u_ex||/||u_ex||
%         x = column array  with npdx LGL nodes in [-1,1]
%         wx= column array  with npdx LGL weigths in [-1,1]
%         dx= derivative matrix produced with derlgl
%         xx = 2-indexes array of size (4,ne) 
%            xx(1:4,ie)=[x_V1_ie;x_V2_ie;x_V3_ie;x_V4_ie]
%            (ne=nex*ney is the global number of spectral elements)
%         jacx = array (length(jacx)=ne); jacx(ie)= (x_V2_ie-x_V1_ie)/2
%         y = npdy LGL nodes in [-1,1], previously generated by xwlgl
%         wy = npdy LGL weigths in [-1,1], previously generated by xwlgl
%         dy= derivative matrix produced with derlgl
%         yy = 2-indexes array of size (4,ne):
%            yy(1:4,ie)=[y_V1_ie;y_V2_ie;y_V3_ie;y_V4_ie]
%         jacy = array (length(jacy)=ne); jacy(ie)= (y_V3_ie-y_V1_ie)/2
%         xy = column array with global mesh, length: noe=nov(npdx*npdy,ne)
%         ww = column array with global weigths, length: noe=nov(npdx*npdy,ne)
%              diag(ww) is the mass matrix associated to SEM discretization
%         nov = local to global map. 2-indexes array, size(nov)=[nov,ne]
%         un = column array with the numerical solution
%         u  = column array with the evaluation of exact solution
%         uex  = exact solution (uex=@(x,y)[uex(x,y)], with .*, .^, ./)
%         uex_x  = exact first x-derivative (uex_x=@(x,y)[uex_x(x,y)], 
%                  with .*, .^, ./)
%         uex_y  = exact first y-derivative (uex_y=@(x,y)[uex_y(x,y)], 
%                  with .*, .^, ./)
%
% Output: err_h1 = error in H1-norm
%
% Reference: CHQZ2 = C. Canuto, M.Y. Hussaini, A. Quarteroni, T.A. Zang,
%                    "Spectral Methods. Fundamentals in Single Domains"
%                    Springer Verlag, Berlin Heidelberg New York, 2006.

%   Written by Paola Gervasio
%   $Date: 2007/04/01$



npdx=length(x); npdy=length(y);
[ldnov,ne]=size(nov); noe=nov(ldnov,ne);
num=0; den=0;
err_h1=0;

if fdq==0

% Legendre Gauss nodes and weigths

[xg,wxg] = xwlg(nq,-1,1);
[yg,wyg] = xwlg(nq,-1,1);
[wxg1,wyg1]=meshgrid(wxg,wyg); wxyg=wxg1.*wyg1;wxyg=wxyg'; wxyg=wxyg(:); 
clear wxg1 wyg1;

% Evaluation of Lagrange basis polynomials at quadrature nodes xg
%
[phix]= intlag_lgl (x,xg);
[phiy]= intlag_lgl (y,yg);

% Loop on spectral elements

for ie=1:ne
un_loc=un(nov(1:ldnov,ie));
[norma_loc1,norma_loc2]=normah1_ex_loc(errtype,nq,uex,uex_x,uex_y,un_loc,...
 wxyg, x,dx,jacx(ie),xx(1:4,ie),xg,phix,...
 y,dy,jacy(ie),yy(1:4,ie),yg,phiy);
num=num+norma_loc1;
den=den+norma_loc2;
end

elseif fdq==1
    
for ie=1:ne
u_loc=u(nov(1:ldnov,ie));
un_loc=un(nov(1:ldnov,ie));
xy_loc=[xy(nov(1:ldnov,ie),1),xy(nov(1:ldnov,ie),2)];
[norma_loc1,norma_loc2]=normah1_loc(errtype,uex_x,uex_y,u_loc,un_loc,...
 xy_loc, wx,dx,jacx(ie),wy,dy,jacy(ie));
num=num+norma_loc1;
den=den+norma_loc2;
end

end
if errtype==0
    err_h1=sqrt(num);
elseif errtype==1
    if abs(den)>1.d-14; err_h1=sqrt(num/den); end
end

return

function [norma_loc1,norma_loc2]=normah1_ex_loc(errtype,nq,uex,uex_x,uex_y,...
 un,wxyg,x,dx,jacx,xx,xg,phix,...
 y,dy,jacy,yy,yg,phiy);

% High degree Legendre Gaussian  formulas to compute H1-norm error
npdx=length(dx);
npdy=length(dy);


% mapping quadrature nodes on element ie

xxg=xg*jacx+(xx(2)+xx(1))*.5;
yyg=yg*jacy+(yy(3)+yy(1))*.5;
[xg1,yg1]=meshgrid(xxg,yyg); xg1=xg1'; yg1=yg1'; xyg=[xg1(:),yg1(:)]; 
clear xg1; clear yg1;


% evaluation of exact solution at quadrature nodes.

[U]=uex(xyg(:,1),xyg(:,2));
[UX]=uex_x(xyg(:,1),xyg(:,2));
[UY]=uex_y(xyg(:,1),xyg(:,2));

% Compute partial numerical derivative
uloc=reshape(un,npdx,npdy);
ux=dx*uloc/jacx;
uy=(dy*uloc')'/jacy;


% evaluate numerical solution and its derivative at quadrature nodes.

uloc_i=phix*(phiy*uloc')';
ux_i=phix*(phiy*ux')';
uy_i=phix*(phiy*uy')';

uloc_i=uloc_i(:);ux_i=ux_i(:); uy_i=uy_i(:);


% compute the sum

norma_loc1=sum(((U-uloc_i).^2+(UX-ux_i).^2+(UY-uy_i).^2).*wxyg)*jacx*jacy;

if errtype==0
    norma_loc2=0;
else
    norma_loc2=sum((U.^2+UX.^2+UY.^2).*wxyg)*jacx*jacy;
end

return

function [norma_loc1,norma_loc2]=normah1_loc(errtype,uex_x,uex_y,U,un_loc,...
 xy_loc, wx,dx,jacx,wy,dy,jacy);

% LGL quadrature formulas on npdx nodes to compute H1-norm error
npdx=length(dx);
npdy=length(dy);
[wx1,wy1]=meshgrid(wx,wy); ww=wx1.*wy1;ww=ww(:); clear wx1 wy1;



% evaluation of exact solution at quadrature nodes.

UX=uex_x(xy_loc(:,1),xy_loc(:,2));
UY=uex_y(xy_loc(:,1),xy_loc(:,2));

% Compute numerical derivative

un_loc=reshape(un_loc,npdx,npdy);
ux=dx*un_loc/jacx; ux=ux(:);
uy=(dy*un_loc')'/jacy; uy=uy(:);
un_loc=un_loc(:);


% compute the sum

norma_loc1=sum(((U-un_loc).^2+(UX-ux).^2+(UY-uy).^2).*ww)*jacx*jacy;
if errtype==0
    norma_loc2=0;
else
    norma_loc2=sum((U.^2+UX.^2+UY.^2).*ww)*jacx*jacy;
end

return

