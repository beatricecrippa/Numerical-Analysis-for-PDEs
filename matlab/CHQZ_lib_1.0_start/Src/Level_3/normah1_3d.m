function [err_h1]=normah1_3d(fdq,nq,errtype,x,wx,dx,xx,jacx,y,wy,dy,yy,jacy,...
z,wz,dz,zz,jacz,xyz,ww,nov,un,u,uex,uex_x,uex_y,uex_z);
% NORMAH1_3D   Computes H1-norm in 3D
%
%  [err_h1]=normah1_3d(fdq,nq,errtype,x,wx,dx,xx,jacx,y,wy,dy,yy,jacy,...
%            z,wz,dz,zz,jacz,xyz,ww,nov,un,u,uex,uex_x,uex_y,uex_z);
%
% Input : fdq = 0  uses Legendre Gauss quadrature formulas with nq nodes
%              in each element (exactness degree = 2*nq+1)
%            = 1  uses Legendre Gauss Lobatto quadrature formulas with npdx/y/z 
%                  quadrature nodes in each element. 
%                Quadrature nodes are the nodes of the mesh. 
%         nq = nodes (in each element and along each direction) 
%              for GL quadrature formulas. Not used if  fdq == 1
%         errtype = 0 for absolute error ||u-u_ex||
%                   1 for relative error ||u-u_ex||/||u_ex||
%         x = column array  with npdx LGL nodes in [-1,1]
%         wx= column array  with npdx LGL weigths in [-1,1]
%         dx= derivative matrix produced with derlgl
%         xx = 2-indexes array of size (8,ne) 
%         xx(1:8,ie)=[x_V1_ie;x_V2_ie;x_V3_ie;x_V4_ie;...
%                        x_V5_ie;x_V6_ie;x_V7_ie;x_V8_ie]
%            (ne=nex*ney is the global number of spectral elements)
%         jacx = array (length(jacx)=ne); jacx(ie)= (x_V2_ie-x_V1_ie)/2
%         y = npdy LGL nodes in [-1,1], previously generated by xwlgl
%         wy = npdy LGL weigths in [-1,1], previously generated by xwlgl
%         dy= derivative matrix produced with derlgl
%         yy = 2-indexes array of size (8,ne):
%         yy(1:8,ie)=[y_V1_ie;y_V2_ie;y_V3_ie;y_V4_ie;...
%                        y_V5_ie;y_V6_ie;y_V7_ie;y_V8_ie]
%         jacy = array (length(jacy)=ne); jacy(ie)= (y_V3_ie-y_V1_ie)/2
%         z = npdy LGL nodes in [-1,1], previously generated by xwlgl
%         wz = npdy LGL weigths in [-1,1], previously generated by xwlgl
%         dz= derivative matrix produced with derlgl
%         zz = 2-indexes array of size (8,ne):
%         zz(1:8,ie)=[z_V1_ie;z_V2_ie;z_V3_ie;z_V4_ie;...
%                        z_V5_ie;z_V6_ie;z_V7_ie;z_V8_ie]
%         jacz = array (length(jacz)=ne); jacz(ie)= (z_V5_ie-z_V1_ie)/2
%         xyz = column array with global mesh, length: noe=nov(npdx*npdy*npdz,ne)
%         ww = column array with global weigths, length: noe=nov(npdx*npdy*npdz,ne)
%              diag(ww) is the mass matrix associated to SEM discretization
%         nov = local to global map. 2-indexes array, size(nov)=[nov,ne]
%         un = column array with the numerical solution
%         u  = column array with the evaluation of exact solution
%         uex  = exact solution (uex=@(x,y,z)[uex(x,y,z)], with .*, .^, ./)
%         uex_x  = exact first x-derivative (uex_x=@(x,y,z)[uex_x(x,y,z)], 
%                  with .*, .^, ./)
%         uex_y  = exact first y-derivative (uex_y=@(x,y,z)[uex_y(x,y,z)], 
%                  with .*, .^, ./)
%         uex_z  = exact first z-derivative (uex_z=@(x,y,z)[uex_y(x,y,z)], 
%                  with .*, .^, ./)
%
% Output: err_h1 = error in H1-norm
%
% Reference: CHQZ2 = C. Canuto, M.Y. Hussaini, A. Quarteroni, T.A. Zang,
%                    "Spectral Methods. Fundamentals in Single Domains"
%                    Springer Verlag, Berlin Heidelberg New York, 2006.

%   Written by Paola Gervasio
%   $Date: 2007/04/01$



npdx=length(x); npdy=length(y); npdz=length(wz);
mn=npdx*npdy;
[ldnov,ne]=size(nov); noe=nov(ldnov,ne);
num=0; den=0;
err_h1=0;

if fdq==0

% Legendre Gauss nodes and weigths

[xg,wxg] = xwlg(nq,-1,1);
yg=xg;zg=xg;
wyg=wxg;wzg=wxg;
wxyg=zeros(ldnov,1);
nq2=nq*nq;nq3=nq*nq2;
for l=1:nq
for j=1:nq
for i=1:nq
wxyg((l-1)*nq2+(j-1)*nq+i)=wxg(i)*wyg(j)*wzg(l);
end
end
end


% Evaluation of Lagrange basis polynomials at quadrature nodes xg
%
[phix]= intlag_lgl (x,xg);
[phiy]= intlag_lgl (y,yg);
[phiz]= intlag_lgl (z,zg);

% Loop on spectral elements

for ie=1:ne
un_loc=un(nov(1:ldnov,ie));
[norma_loc1,norma_loc2]=normah1_ex_loc(errtype,nq,uex,uex_x,uex_y,uex_z,...
 un_loc,wxyg,...
 x,dx,jacx(ie),xx(1:8,ie),xg,phix,...
 y,dy,jacy(ie),yy(1:8,ie),yg,phiy,...
 z,dz,jacz(ie),zz(1:8,ie),zg,phiz);
num=num+norma_loc1;
den=den+norma_loc2;
end

elseif fdq==1
    
for ie=1:ne
nn=nov(1:ldnov,ie);
u_loc=u(nn);
un_loc=un(nn);
xyz_loc=[xyz(nn,1),xyz(nn,2),xyz(nn,3)];
[norma_loc1,norma_loc2]=normah1_loc(errtype,uex_x,uex_y,uex_z,u_loc,un_loc,...
 xyz_loc, wx,dx,jacx(ie),wy,dy,jacy(ie),wz,dz,jacz(ie));
num=num+norma_loc1;
den=den+norma_loc2;
end

end
if errtype==0
    err_h1=sqrt(num);
elseif errtype==1
    if abs(den)>1.d-14; err_h1=sqrt(num/den); end
end

return

function [norma_loc1,norma_loc2]=normah1_ex_loc(errtype,nq,uex,uex_x,uex_y,...
 uex_z,un,wxyg,x,dx,jacx,xx,xg,phix,...
 y,dy,jacy,yy,yg,phiy,z,dz,jacz,zz,zg,phiz);

% High degree Legendre Gaussian  formulas to compute H1-norm error
npdx=length(dx);
npdy=length(dy);
npdz=length(dz);
mn=npdx*npdy;

% mapping quadrature nodes on element ie

xxg=xg*jacx+(xx(2)+xx(1))*.5;
yyg=yg*jacy+(yy(3)+yy(1))*.5;
zzg=zg*jacz+(zz(5)+zz(1))*.5;
ldnov=mn*npdz;

nq2=nq*nq;nq3=nq2*nq;
for l=1:nq
for j=1:nq
for i=1:nq
    k=(l-1)*nq2+(j-1)*nq+i;
xyg(k,1:3)=[xxg(i),yyg(j),zzg(l)];
end
end
end
jac=jacx*jacy*jacz;

% evaluation of exact solution at quadrature nodes.

[U]=zeros(nq3,1)+uex(xyg(:,1),xyg(:,2),xyg(:,3));
[UX]=zeros(nq3,1)+uex_x(xyg(:,1),xyg(:,2),xyg(:,3));
[UY]=zeros(nq3,1)+uex_y(xyg(:,1),xyg(:,2),xyg(:,3));
[UZ]=zeros(nq3,1)+uex_z(xyg(:,1),xyg(:,2),xyg(:,3));

% Compute partial numerical derivative

uloc=reshape(un,npdx,npdy,npdz);
for l=1:npdz
ux(:,:,l)=dx*uloc(:,:,l)/jacx;
uy(:,:,l)=(dy*(uloc(:,:,l))')'/jacy;
uloc_z(l,:,:)=uloc(:,:,l);
end

for j=1:npdy
uz_z(:,:,j)=dz*uloc_z(:,:,j)/jacz;
end

for l=1:npdz
ux_z(l,:,:)=ux(:,:,l);
uy_z(l,:,:)=uy(:,:,l);
end

% evaluate numerical solution and its derivative at quadrature nodes.

for j=1:npdy
tt_z(:,:,j)=phiz*uloc_z(:,:,j);
end
for l=1:nq
tt(:,:,l)=tt_z(l,:,:);
end
for l=1:nq
uloc_i(:,:,l)=phix*(phiy*(tt(:,:,l))')';
end

for j=1:npdy
tt_z(:,:,j)=phiz*ux_z(:,:,j);
end
for l=1:nq
tt(:,:,l)=tt_z(l,:,:);
end
for l=1:nq
ux_i(:,:,l)=phix*(phiy*(tt(:,:,l))')';
end

for j=1:npdy
tt_z(:,:,j)=phiz*uy_z(:,:,j);
end
for l=1:nq
tt(:,:,l)=tt_z(l,:,:);
end
for l=1:nq
uy_i(:,:,l)=phix*(phiy*(tt(:,:,l))')';
end

for j=1:npdy
tt_z(:,:,j)=phiz*uz_z(:,:,j);
end
for l=1:nq
tt(:,:,l)=tt_z(l,:,:);
end
for l=1:nq
uz_i(:,:,l)=phix*(phiy*(tt(:,:,l))')';
end




uloc_i=uloc_i(:);ux_i=ux_i(:); uy_i=uy_i(:); uz_i=uz_i(:);


% compute the sum

norma_loc1=sum(((U-uloc_i).^2+(UX-ux_i).^2+(UY-uy_i).^2+(UZ-uz_i).^2).*wxyg)*jac;

if errtype==0
    norma_loc2=0;
else
    norma_loc2=sum((U.^2+UX.^2+UY.^2+UZ.^2).*wxyg)*jac;
end

return

function [norma_loc1,norma_loc2]=normah1_loc(errtype,uex_x,uex_y,uex_z,U,...
un_loc,xyz_loc, wx,dx,jacx,wy,dy,jacy,wz,dz,jacz);

% LGL quadrature formulas on npdx nodes to compute H1-norm error
npdx=length(dx);
npdy=length(dy);
npdz=length(dz);
mn=npdx*npdy;
ldnov=mn*npdz;
ww=zeros(ldnov,1);
for l=1:npdz
for j=1:npdy
for i=1:npdx
ww((l-1)*mn+(j-1)*npdx+i)=wx(i)*wy(j)*wz(l);
end
end
end
jac=jacx*jacy*jacz;


% evaluation of exact solution at quadrature nodes.

UX=uex_x(xyz_loc(:,1),xyz_loc(:,2),xyz_loc(:,3));
UY=uex_y(xyz_loc(:,1),xyz_loc(:,2),xyz_loc(:,3));
UZ=uex_z(xyz_loc(:,1),xyz_loc(:,2),xyz_loc(:,3));

% Compute numerical derivative

un_loc=reshape(un_loc,npdx,npdy,npdz);
for l=1:npdz
ux(:,:,l)=dx*un_loc(:,:,l)/jacx;
uy(:,:,l)=(dy*(un_loc(:,:,l))')'/jacy; 
un_loc_z(l,:,:)=un_loc(:,:,l);
end
for j=1:npdy
uz_z(:,:,j)=dz*un_loc_z(:,:,j)/jacz;
end

for l=1:npdz
uz(:,:,l)=uz_z(l,:,:);
end
ux=ux(:);
uy=uy(:);
uz=uz(:);
un_loc=un_loc(:);


% compute the sum

norma_loc1=sum(((U-un_loc).^2+(UX-ux).^2+(UY-uy).^2+(UZ-uz).^2).*ww)*jac;
if errtype==0
    norma_loc2=0;
else
    norma_loc2=sum((U.^2+UX.^2+UY.^2+UZ.^2).*ww)*jac;
end

return

