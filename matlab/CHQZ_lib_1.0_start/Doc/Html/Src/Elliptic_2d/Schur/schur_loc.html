<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of schur_loc</title>
  <meta name="keywords" content="schur_loc">
  <meta name="description" content="SCHUR_LOC Computes local matrices and lists for implementing the Schur method">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">Src</a> &gt; <a href="../index.html">Elliptic_2d</a> &gt; <a href="index.html">Schur</a> &gt; schur_loc.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for Src/Elliptic_2d/Schur&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>schur_loc
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>SCHUR_LOC Computes local matrices and lists for implementing the Schur method</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [AGG,Amm,AGm,Lmm,LGG,Am,f]=schur_loc(ifro,nov,wx,dx,jacx,wy,dy,jacy,nvli,gam,f,ub,param); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> SCHUR_LOC Computes local matrices and lists for implementing the Schur method

 Computes local matrices and lists for implementing Schur complement algorithm 

 Input :  ifro = column array of length noe=nov(npdx*npdy,ne):
            if (x_i,y_i) is internal to Omega then ifro(i)=0,
            if (x_i,y_i) is on \partial\Omega then ifro(i)=1,
          nov = local -global map, previously generated by cosnov_2d
          wx = npdx LGL weigths in [-1,1], previously generated by xwlgl
          dx =first derivative LGL matrix (by calling dx=derlgl(x,npdx))
          jacx = array (length(jacx)=ne); jacx(ie)= (x_V2_ie-x_V1_ie)/2
          wy = npdy LGL weigths in [-1,1],
              (produced by calling [y,wy]=xwlgl(npdy))
          dy =first derivative LGL matrix (by calling dy=derlgl(y,npdy))
          jacy = array (length(jacy)=ne); jacy(ie)= (y_V3_ie-y_V1_ie)/2
          nvli = column array with number of internal nodes of each
          gam   = coefficient of zeroth order term (constant&gt;=0)
          f = r.h.s. column array
          ub =  column array with the solution on the boundary
          param = array of parameters. only param(1) is used.

 Output: AGG = structure of local matrices A_{\Gamma_m,\Gamma_m}
         Amm = structure of local matrices (A_{m,m})^{-1}
         AGm = structure of local matrices A_{\Gamma_m,m}
         Lmm = structure containing maps from internal{\Omega_m to \Omega_m
                 set in schur_local.m
         LGG = structure with maps from \Gamma_i to \Gamma
                 set in schur_local.m
         novg = restriction map from (\cup_i \Omega_i) to \Gamma
                 set in cosnovg.m
         Rgamma = matrix of size (ne, ngamma) (defined in CHQZ3, pag. 399)
                  (R_\Gamma)_ij: =  1/n_j     if  x_j \in \Gamma_i
                                 =  0         otherwise

 References: CHQZ3 = C. Canuto, M.Y. Hussaini, A. Quarteroni, T.A. Zang,
                    &quot;Spectral Methods. Evolution to Complex Geometries 
                     and Applications to Fluid DynamicsSpectral Methods&quot;
                    Springer Verlag, Berlin Heidelberg New York, 2007.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../Src/Level_2/liste1.html" class="code" title="function [lbor,lint,lintint,lgamma]=liste1(ifro);">liste1</a>	LISTE1 Assembles lists of internal, boundary, interface nodes (similar to liste)</li><li><a href="../../../Src/Level_2/stiff_2d_sp.html" class="code" title="function [A]=stiff_2d_sp(wx,dx,jacx,wy,dy,jacy);">stiff_2d_sp</a>	STIFF_2D_SP Computes 2D local SEM matrix associated to (nabla(phi_j), nabla(phi_i))_N</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="schur_2d.html" class="code" title="function [xy,un,param]=schur_2d(xa,xb,ya,yb,gam,uex,uex_x,uex_y,ff,g,h,cb,nex,nx,ney,ny,gammax,gammay,param);">schur_2d</a>	SCHUR_2D   Numerical solution of the 2D b.v.p. -Delta u + gam u -Schur complement</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [AGG,Amm,AGm,Lmm,LGG,Am,f]=schur_loc(ifro,nov,</a><span class="keyword">...</span>
0002     wx,dx,jacx,wy,dy,jacy,nvli,gam,f,ub,param);
0003 <span class="comment">% SCHUR_LOC Computes local matrices and lists for implementing the Schur method</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Computes local matrices and lists for implementing Schur complement algorithm</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Input :  ifro = column array of length noe=nov(npdx*npdy,ne):</span>
0008 <span class="comment">%            if (x_i,y_i) is internal to Omega then ifro(i)=0,</span>
0009 <span class="comment">%            if (x_i,y_i) is on \partial\Omega then ifro(i)=1,</span>
0010 <span class="comment">%          nov = local -global map, previously generated by cosnov_2d</span>
0011 <span class="comment">%          wx = npdx LGL weigths in [-1,1], previously generated by xwlgl</span>
0012 <span class="comment">%          dx =first derivative LGL matrix (by calling dx=derlgl(x,npdx))</span>
0013 <span class="comment">%          jacx = array (length(jacx)=ne); jacx(ie)= (x_V2_ie-x_V1_ie)/2</span>
0014 <span class="comment">%          wy = npdy LGL weigths in [-1,1],</span>
0015 <span class="comment">%              (produced by calling [y,wy]=xwlgl(npdy))</span>
0016 <span class="comment">%          dy =first derivative LGL matrix (by calling dy=derlgl(y,npdy))</span>
0017 <span class="comment">%          jacy = array (length(jacy)=ne); jacy(ie)= (y_V3_ie-y_V1_ie)/2</span>
0018 <span class="comment">%          nvli = column array with number of internal nodes of each</span>
0019 <span class="comment">%          gam   = coefficient of zeroth order term (constant&gt;=0)</span>
0020 <span class="comment">%          f = r.h.s. column array</span>
0021 <span class="comment">%          ub =  column array with the solution on the boundary</span>
0022 <span class="comment">%          param = array of parameters. only param(1) is used.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% Output: AGG = structure of local matrices A_{\Gamma_m,\Gamma_m}</span>
0025 <span class="comment">%         Amm = structure of local matrices (A_{m,m})^{-1}</span>
0026 <span class="comment">%         AGm = structure of local matrices A_{\Gamma_m,m}</span>
0027 <span class="comment">%         Lmm = structure containing maps from internal{\Omega_m to \Omega_m</span>
0028 <span class="comment">%                 set in schur_local.m</span>
0029 <span class="comment">%         LGG = structure with maps from \Gamma_i to \Gamma</span>
0030 <span class="comment">%                 set in schur_local.m</span>
0031 <span class="comment">%         novg = restriction map from (\cup_i \Omega_i) to \Gamma</span>
0032 <span class="comment">%                 set in cosnovg.m</span>
0033 <span class="comment">%         Rgamma = matrix of size (ne, ngamma) (defined in CHQZ3, pag. 399)</span>
0034 <span class="comment">%                  (R_\Gamma)_ij: =  1/n_j     if  x_j \in \Gamma_i</span>
0035 <span class="comment">%                                 =  0         otherwise</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% References: CHQZ3 = C. Canuto, M.Y. Hussaini, A. Quarteroni, T.A. Zang,</span>
0038 <span class="comment">%                    &quot;Spectral Methods. Evolution to Complex Geometries</span>
0039 <span class="comment">%                     and Applications to Fluid DynamicsSpectral Methods&quot;</span>
0040 <span class="comment">%                    Springer Verlag, Berlin Heidelberg New York, 2007.</span>
0041 
0042 <span class="comment">%   Written by Paola Gervasio</span>
0043 <span class="comment">%   $Date: 2007/04/01$</span>
0044 
0045 [ldnov,ne]=size(nov);
0046 noe=nov(ldnov,ne); 
0047 npdx=length(wx); npdy=length(wy); mn=npdx*npdy;
0048 
0049 
0050 Amm=cell(ne,1); AGG=cell(ne,1); AGm=cell(ne,1);
0051 Lmm=cell(ne,1);LGG=cell(ne,1);
0052 Am=cell(ne,1);
0053 [wx1,wy1]=meshgrid(wx,wy); w_ie=wx1.*wy1; w_ie=w_ie'; w_ie=w_ie(:); clear wx1 wy1;
0054 
0055 <span class="keyword">for</span> ie=1:ne
0056 Al=sparse(mn,mn);
0057 [Al]=<a href="../../../Src/Level_2/stiff_2d_sp.html" class="code" title="function [A]=stiff_2d_sp(wx,dx,jacx,wy,dy,jacy);">stiff_2d_sp</a>(wx,dx,jacx(ie),wy,dy,jacy(ie));
0058 jac=jacx(ie)*jacy(ie);
0059 
0060 Al=Al+jac*gam*spdiags(w_ie,0,mn,mn);
0061 
0062 <span class="comment">% Ali is the block of Al relative to internal nodes</span>
0063 
0064 ifro_l=ifro(nov(1:mn,ie));
0065 ub_loc=ub(nov(1:mn,ie));
0066 [lbor,lint]=<a href="../../../Src/Level_2/liste1.html" class="code" title="function [lbor,lint,lintint,lgamma]=liste1(ifro);">liste1</a>(ifro_l);
0067 <span class="keyword">if</span>(isempty(lbor)==0)
0068 f(nov(lint,ie))=f(nov(lint,ie))-Al(lint,lbor)*ub_loc(lbor);
0069 <span class="keyword">end</span>
0070 
0071 Ali=Al(lint,lint); 
0072 ifroi=ifro_l(lint);
0073 [lbor,lint,lintint,lg]=<a href="../../../Src/Level_2/liste1.html" class="code" title="function [lbor,lint,lintint,lgamma]=liste1(ifro);">liste1</a>(ifroi);
0074 Lmm(ie)={lintint}; LGG(ie)={lg};
0075 ngammam=length(lg);
0076 AGG(ie)={Ali(lg,lg)};
0077 AGm(ie)={Ali(lg,lintint)};
0078 Amm(ie)={inv(Ali(lintint,lintint))};
0079 
0080 <span class="comment">% Assemble preconditioner on the element ie.</span>
0081 <span class="comment">% Mass/H^2 is added if the boundary of element ie  and boundary of</span>
0082 <span class="comment">% Omega have null intersection</span>
0083 
0084 <span class="keyword">if</span>(param(1)~=1)
0085 <span class="keyword">if</span> nvli(ie)==mn
0086     
0087 <span class="comment">% ww is not multiplied by jac, since Mass/H^2= diag(ww*jac)/jac</span>
0088     
0089 Ali=Ali+spdiags(w_ie,0,mn,mn);
0090 <span class="keyword">end</span>
0091 Am(ie)={sparse(chol(Ali))};
0092 <span class="keyword">end</span>
0093 
0094 <span class="comment">% end loop on ie</span>
0095 <span class="keyword">end</span>
0096</pre></div>
<hr><address>Generated on Fri 21-Sep-2007 10:07:00 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>