function [ha]=plot_sem_2d(fig,command,nex,ney,x,xx,jacx,y,yy,jacy,xy,ww,nov,...
    u,n_int);
% PLOT_SEM_2D Plots SEM numerical solution of 2D boundary value problems
%
%  [ha]=plot_sem_2d(fig,command,nex,ney,x,xx,jacx,y,yy,jacy,xy,ww,nov,...
%    u,n_int);
%
% Input: fig =  figure number, set in the colling function by figure
%                command
%        command = either 'mesh', 'surf' or 'contour'
%        nex = number of Spectral elements along x-direction
%        ney = number of Spectral elements along y-direction
%        x = LGL nodes in [-1,1] along x-direction
%        xx = 2-indexes array of size (4,ne)
%            xx(1:4,ie)=[x_V1_ie;x_V2_ie;x_V3_ie;x_V4_ie]
%            (ne=nex*ney is the global number of spectral elements)
%        jacx = array (length(jacx)=ne); jacx(ie)= (x_V2_ie-x_V1_ie)/2
%        y = LGL nodes in [-1,1] along y-direction
%        yy = 2-indexes array of size (4,ne)
%            yy(1:4,ie)=[y_V1_ie;y_V2_ie;y_V3_ie;y_V4_ie]
%            (ne=nex*ney is the global number of spectral elements)
%        jacy = array (length(jacy)=ne); jacy(ie)= (y_V3_ie-y_V1_ie)/2
%        xy = column array with global mesh, length: noe=nov(npdx*npdy,ne)
%        ww = column array with global weigths, length: noe=nov(npdx*npdy,ne)
%             diag(ww) is the mass matrix associated to SEM discretization
%        nov = local -global map, previously generated by cosnov_2d
%        u = numerical solution
%        n_int = number of nodes in each element to interpolate numerical
%        solution by Level_0/legendre_tr_eval.m (Discrete Legendre Transform)
%
% Output: ha=gca of figure fig

%   Written by Paola Gervasio
%   $Date: 2007/04/01$

%
%
%
npdx=length(x);
npdy=length(y);
npdx1=n_int; npdy1=npdx1;
hf=figure(fig);clf
axis([min(xy(:,1)),max(xy(:,1)),min(xy(:,2)),max(xy(:,2))]);hold on
ne=nex*ney;

if nargin ==16
    % plot without interpolating
    cmin=min(u);cmax=max(u);
    caxis([cmin,cmax])
    
    for ie=1:ne
        mn=npdx*npdy;
        ctx=jacx(ie)*x+0.5*(xx(2,ie)+xx(1,ie));
        cty=jacy(ie)*y+0.5*(yy(3,ie)+yy(1,ie));
        clear uloc;
        uloc=reshape(u(nov(1:mn,ie)),npdx,npdy);
        if command(1,1)=='c'
            contour(ctx,cty,uloc',35);
        else
            eval([command,'(ctx,cty,uloc'')']);
        end
        
    end
    ha=gca;
    if command(1,1)~='c'
        set(ha,'view',[-36,34]);
    end
else
    
    % plot with interpolation
    
    u_int=zeros(npdy1,npdx1,ne);
    
    for ie=1:ne
        mn=npdx*npdy;
        
        x1=xwlgl(npdx1); y1=xwlgl(npdy1);
        
        uloc=reshape(u(nov(1:mn,ie)),npdx,npdy);
        [u1x]=legendre_tr_eval(x,uloc,x1);
        [u1y]=legendre_tr_eval(y,u1x',y1);
        
        u_int(:,:,ie)=u1y;
        if command(1,1)~='c'
            ctx=jacx(ie)*x1+0.5*(xx(2,ie)+xx(1,ie));
            cty=jacy(ie)*y1+0.5*(yy(3,ie)+yy(1,ie));
            eval([command,'(ctx,cty,u1y)']);hold on
            %axis([-1,1,-1,1])
            alpha(1)
        end
        
    end
    ha=gca;
    set(ha,'Fontname','Times',...
        'FontSize',16,...
        'Xgrid','on','YGrid','on','Linewidth',2);
    
    if command(1,1)~='c'
        set(ha,'view',[-36,34])
    else
        cmin=min(min(min(u_int)));
        cmax=max(max(max(u_int)));
        caxis([cmin,cmax]);
        V=linspace(cmin,cmax,35);
        for ie=1:ne
            ctx=jacx(ie)*x1+0.5*(xx(2,ie)+xx(1,ie));
            cty=jacy(ie)*y1+0.5*(yy(3,ie)+yy(1,ie));
            u1=u_int(:,:,ie);
            
            contour(ctx,cty,u1,V,'LineWidth',2);
        end
    end
end
