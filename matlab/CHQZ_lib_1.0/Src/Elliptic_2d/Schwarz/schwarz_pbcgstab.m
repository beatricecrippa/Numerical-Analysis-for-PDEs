function [u,iter,res]=schwarz_pbcgstab(u0, f, param,...
    p_unity,...
    xy, ww, A, nov, noei, lint,x,wx,y,wy,xx,jacx,yy,jacy,...
    Aq1, wwq1, linte,nove,nvle,...
    Ac, Acb, wwc, r0t,lista_coarse,noec,novc,lintc,ldirc);
% SCHWARZ_PBCGSTAB BiCGStab method with additive Schwarz preconditioner with overlap and coarse mesh
%
% [u,iter,res]=schwarz_pbcgstab(u0, f, param,...
%    p_unity,...
%    xy, ww, A, nov, noei, lint,x,wx,y,wy,xx,jacx,yy,jacy,...
%    Aq1, wwq1, linte,nove,nvle,...
%    Ac, Acb, wwc, r0t,lista_coarse,noec,novc,lintc,ldirc);
%
% Input : u0 = column array, initial datum for pbcgstab
%         f = column array, r.h.s. of linear system to solve
%         param = array of parameters
%         p_unity = unity partition associated to extended elements
%         xy = 2-indexes array wiht coordinates of 2D LGL mesh
%         ww = mass matrix (in column array)
%         nov = local -global map, previously generated by cosnov_2d
%         noei = number of  nodes internal to Omega
%         lint = list of internal nodes (set in liste.n)
%         x = npdx LGL nodes in [-1,1],
%            (produced by calling [x,wx]=xwlgl(npdx))
%         wx= npdx LGL weigths in [-1,1],
%            (produced by calling [x,wx]=xwlgl(npdx))
%         y = npdx LGL nodes in [-1,1],
%            (produced by calling [y,wy]=xwlgl(npdy))
%         wy= npdx LGL weigths in [-1,1],
%            (produced by calling [y,wy]=xwlgl(npdy))
%         xx = 2-indexes array of size (4,ne)
%            xx(1:4,ie)=[x_V1_ie;x_V2_ie;x_V3_ie;x_V4_ie]
%            (ne=nex*ney is the global number of spectral elements)
%         jacx = array (length(jacx)=ne); jacx(ie)= (x_V2_ie-x_V1_ie)/2
%         yy = 2-indexes array of size (4,ne):
%            yy(1:4,ie)=[y_V1_ie;y_V2_ie;y_V3_ie;y_V4_ie]
%         jacy = array (length(jacy)=ne); jacy(ie)= (x_V3_ie-x_V1_ie)/2
%         Aq1 = cell array with Q1 stiffness matrices (internal/internal nodes)
%               on extended elements
%         wwq1 = cell array with Q1 mass matrices (internal nodes)
%                on extended elements
%         linte = cell array with list of internal nodes of extended
%                 elements
%         nove = 2-index array of "extended local" to global map, permuted.
%         nvle = 2-index array:
%                 nvle (:,1)=number of nodes of the extendend elements
%                 nvle (:,2)=number of Q1 elements of the extendend elements
%                            along x-direction
%                 nvle (:,3)=number of Q1 elements of the extendend elements
%                            along y-direction
%        Ac =  Cholesky factor of the Q1 stiffness matrix
%               (internal/internal nodes) on the coarse mesh
%        Acb = Q1 stiffness matrix (internal/boundary nodes)
%               on the coarse mesh
%        wwc = Q1 mass matrix (internal nodes)
%                on the coarse mesh
%        r0t =  matrix R_H^T
%        lista_coarse = list of nodes of Omega wich are nodes of the coarse mesh
%        noec = number of nodes of the coarse mesh
%        novc(4,ne) = it maps each macro-Q1 element on the coarse mesh Q1
%        lintc = lista of internal nodes of the coarse mesh
%        ldirc = lista of boudanry nodes of the coarse mesh
%
% Output: u = column array of PCG solution
%         iter = number of iterations required to satisfy stopping test
%                ||r^(k)||/||b|| < tol
%         res =  value of ||r^(k)||/||b|| at last iteration.
%
% References: CHQZ2 = C. Canuto, M.Y. Hussaini, A. Quarteroni, T.A. Zang,
%                    "Spectral Methods. Fundamentals in Single Domains"
%                    Springer Verlag, Berlin Heidelberg New York, 2006.
%             CHQZ3 = C. Canuto, M.Y. Hussaini, A. Quarteroni, T.A. Zang,
%                    "Spectral Methods. Evolution to Complex Geometries 
%                     and Applications to Fluid DynamicsSpectral Methods"
%                    Springer Verlag, Berlin Heidelberg New York, 2007.

%   Written by Paola Gervasio
%   $Date: 2007/04/01$

tol=param(10); itmax=param(11);
[ldnov,ne]=size(nov);
u=u0;
bb=norm(f);
res=[];
r=f-A*u0;
rtilde=r;
p=r;
rr0=r'*r;
normar0=sqrt(r'*r);
err=normar0/bb; iter=0;


while  err > tol & iter < itmax

z=precoasc(p,param,noei,lint,p_unity,...
    xy, ww, nov, x,wx,y,wy,xx, jacx,yy,jacy,...
    Aq1, wwq1, linte, nove,nvle,...
    Ac, Acb, wwc, r0t,lista_coarse,noec,novc,lintc,ldirc);
%v=A*p;
v=A*z;
alpha=rr0/(rtilde'*v);
s=r-alpha*v;
ss=precoasc(s,param,noei,lint,p_unity,...
    xy, ww, nov, x,wx,y,wy,xx, jacx,yy,jacy,...
    Aq1, wwq1, linte, nove,nvle,...
    Ac, Acb, wwc, r0t,lista_coarse,noec,novc,lintc,ldirc);
t=A*ss;
w=(t'*s)/(t'*t);
u=u+alpha*z+w*ss;
r=s-w*t;
rr=rtilde'*r;
beta=rr/rr0;
p=r+(rr*alpha)/(rr0*w)*(p-w*v);
rr0=rr;
err=sqrt(r'*r)/normar0;
if(abs(alpha)<eps) err=0; 
    disp('schwarz_pcg: a break occurred')
end

%fprintf('iter=%d alpha=%12.6e err=%12.6e \n',iter,alpha,err)
%res=[res;err];
iter=iter+1;
rr0=rr;


%fprintf('It. Bicgstab %d, err %13.6e \n',iter,err)
end
if err>tol & iter>=itmax
fprintf('The method does not converge in %d iterations\n',iter)
end
res=err;
return
