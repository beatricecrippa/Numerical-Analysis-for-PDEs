function [AGG,Amm,AGm,Lmm,LGG,Am,f]=schur_loc(ifro,nov,...
    wx,dx,jacx,wy,dy,jacy,nvli,gam,f,ub,param);
% SCHUR_LOC Computes local matrices and lists for implementing the Schur method
%
% Computes local matrices and lists for implementing Schur complement algorithm 
%
% Input :  ifro = column array of length noe=nov(npdx*npdy,ne):
%            if (x_i,y_i) is internal to Omega then ifro(i)=0,
%            if (x_i,y_i) is on \partial\Omega then ifro(i)=1,
%          nov = local -global map, previously generated by cosnov_2d
%          wx = npdx LGL weigths in [-1,1], previously generated by xwlgl
%          dx =first derivative LGL matrix (by calling dx=derlgl(x,npdx))
%          jacx = array (length(jacx)=ne); jacx(ie)= (x_V2_ie-x_V1_ie)/2
%          wy = npdy LGL weigths in [-1,1],
%              (produced by calling [y,wy]=xwlgl(npdy))
%          dy =first derivative LGL matrix (by calling dy=derlgl(y,npdy))
%          jacy = array (length(jacy)=ne); jacy(ie)= (y_V3_ie-y_V1_ie)/2
%          nvli = column array with number of internal nodes of each
%          gam   = coefficient of zeroth order term (constant>=0)
%          f = r.h.s. column array
%          ub =  column array with the solution on the boundary
%          param = array of parameters. only param(1) is used.
%
% Output: AGG = structure of local matrices A_{\Gamma_m,\Gamma_m}
%         Amm = structure of local matrices (A_{m,m})^{-1}
%         AGm = structure of local matrices A_{\Gamma_m,m}
%         Lmm = structure containing maps from internal{\Omega_m to \Omega_m
%                 set in schur_local.m
%         LGG = structure with maps from \Gamma_i to \Gamma
%                 set in schur_local.m
%         novg = restriction map from (\cup_i \Omega_i) to \Gamma
%                 set in cosnovg.m
%         Rgamma = matrix of size (ne, ngamma) (defined in CHQZ3, pag. 399)
%                  (R_\Gamma)_ij: =  1/n_j     if  x_j \in \Gamma_i
%                                 =  0         otherwise
%
% References: CHQZ3 = C. Canuto, M.Y. Hussaini, A. Quarteroni, T.A. Zang,
%                    "Spectral Methods. Evolution to Complex Geometries 
%                     and Applications to Fluid DynamicsSpectral Methods"
%                    Springer Verlag, Berlin Heidelberg New York, 2007.

%   Written by Paola Gervasio
%   $Date: 2007/04/01$

[ldnov,ne]=size(nov);
noe=nov(ldnov,ne); 
npdx=length(wx); npdy=length(wy); mn=npdx*npdy;


Amm=cell(ne,1); AGG=cell(ne,1); AGm=cell(ne,1);
Lmm=cell(ne,1);LGG=cell(ne,1);
Am=cell(ne,1);
[wx1,wy1]=meshgrid(wx,wy); w_ie=wx1.*wy1; w_ie=w_ie'; w_ie=w_ie(:); clear wx1 wy1;

for ie=1:ne
Al=sparse(mn,mn);
[Al]=stiff_2d_sp(wx,dx,jacx(ie),wy,dy,jacy(ie));
jac=jacx(ie)*jacy(ie);

Al=Al+jac*gam*spdiags(w_ie,0,mn,mn);

% Ali is the block of Al relative to internal nodes

ifro_l=ifro(nov(1:mn,ie));
ub_loc=ub(nov(1:mn,ie));
[lbor,lint]=liste1(ifro_l);
if(isempty(lbor)==0)
f(nov(lint,ie))=f(nov(lint,ie))-Al(lint,lbor)*ub_loc(lbor);
end

Ali=Al(lint,lint); 
ifroi=ifro_l(lint);
[lbor,lint,lintint,lg]=liste1(ifroi);
Lmm(ie)={lintint}; LGG(ie)={lg};
ngammam=length(lg);
AGG(ie)={Ali(lg,lg)};
AGm(ie)={Ali(lg,lintint)};
Amm(ie)={inv(Ali(lintint,lintint))};

% Assemble preconditioner on the element ie.
% Mass/H^2 is added if the boundary of element ie  and boundary of 
% Omega have null intersection

if(param(1)~=1)
if nvli(ie)==mn
    
% ww is not multiplied by jac, since Mass/H^2= diag(ww*jac)/jac
    
Ali=Ali+spdiags(w_ie,0,mn,mn);
end
Am(ie)={sparse(chol(Ali))};
end

% end loop on ie
end

