function [err_inf,err_h1,err_l2]=errors_3d(x,wx,dx,xx,jacx,y,wy,dy,yy,jacy,...
z,wz,dz,zz,jacz,...
xyz,ww,nov,un,uex,uex_x,uex_y,uex_z,param);
% ERRORS_3D Computes errors for 3D b.v.p.
%
% Input:
%        x = npdx LGL nodes in [-1,1], previously generated by xwlgl
%        wx = npdx LGL weigths in [-1,1], previously generated by xwlgl
%        dx = LGL 1-st derivative matrix previously generated by derlgl
%        xx = 2-indexes array of size (8,ne)
%            xx(1:8,ie)=[x_V1_ie;x_V2_ie;x_V3_ie;x_V4_ie;
%                        x_V5_ie;x_V6_ie;x_V7_ie;x_V8_ie]
%            (ne=nex*ney is the global number of spectral elements)
%        jacx = array (length(jacx)=ne); jacx(ie)= (x_V2_ie-x_V1_ie)/2
%        y = npdx LGL nodes in [-1,1], previously generated by xwlgl
%        wy = npdx LGL weigths in [-1,1], previously generated by xwlgl
%        dy = LGL 1-st derivative matrix previously generated by derlgl
%        yy = 2-indexes array of size (8,ne)
%            yy(1:8,ie)=[y_V1_ie;y_V2_ie;y_V3_ie;y_V4_ie;
%                        y_V5_ie;y_V6_ie;y_V7_ie;y_V8_ie]
%            (ne=nex*ney is the global number of spectral elements)
%        jacy = array (length(jacy)=ne); jacy(ie)= (y_V3_ie-y_V1_ie)/2
%        z = npdz LGL nodes in [-1,1], previously generated by xwlgl
%        wz = npdz LGL weigths in [-1,1], previously generated by xwlgl
%        dz = LGL 1-st derivative matrix previously generated by derlgl
%        zz = 2-indexes array of size (8,ne)
%            zz(1:8,ie)=[z_V1_ie;z_V2_ie;z_V3_ie;z_V4_ie;
%                        z_V5_ie;z_V6_ie;z_V7_ie;z_V8_ie]
%            (ne=nex*ney is the global number of spectral elements)
%        jacz = array (length(jacz)=ne); jacz(ie)= (z_V5_ie-z_V1_ie)/2
%        xyz = column array with global mesh, length: noe=nov(npdx*npdy*npdz,ne)
%        ww = column array with global weigths, 
%               length: noe=nov(npdx*npdy*npdz,ne)
%              diag(ww) is the mass matrix associated to SEM discretization
%        nov = local -global map, previously generated by mesh_3d
%        un = numerical solution
%        uex  = exact solution (uex=@(x,y,z)[uex(x,y,z)], with .*, .^, ./)
%        uex_x  = exact first x-derivative (uex_x=@(x,y,z)[uex_x(x,y,z)], with .*, .^, ./)
%        uex_y  = exact first y-derivative (uex_y=@(x,y,z)[uex_y(x,y,z)], with .*, .^, ./)
%        uex_z  = exact first z-derivative (uex_z=@(x,y,z)[uex_z(x,y,z)], with .*, .^, ./)
%        param(4) = 1: compute errors (L^inf-norm, L2-norm, H1-norm)
%                      on the exact solution
%                   2: no  errors are computed
%        param(5) = 0: LG quadrature formulas with high precision degree are
%                      used to compute norms (exact norms)
%                   1: LGL quadrature formulas with npdx,npdy,npdz nodes are
%                      used to compute norms (discrete norms)
%                   (used only if param(4) == 1)
%        param(6) = number of nodes for high degree quadrature formula,
%                   (used only if param(5) == 0 & param(4) == 1)
%        param(7) = 0: absolute errors are computed
%                   1: relative errors are computed
%                   (used only if param(4) == 1)
%
% Output:
%
%         err_inf = ||u_ex-u_N|| with respect to discrete maximum-norm
%         err_h1 = ||u_ex-u_N|| with respect to discrete H1-norm
%         err_l2 = ||u_ex-u_N|| with respect to discrete L2-norm
%
% Reference: CHQZ2 = C. Canuto, M.Y. Hussaini, A. Quarteroni, T.A. Zang,
%                    "Spectral Methods. Fundamentals in Single Domains"
%                    Springer Verlag, Berlin Heidelberg New York, 2006.

%   Written by Paola Gervasio
%   $Date: 2007/04/01$


fdq=param(5); 
if fdq ==0
nq=param(6);
else 
nq=length(wx);
end
errtype=param(7);

% compute errors on the exact solution

npdx=length(wx); npdy=length(wy); npdz=length(wz);
[ldnov,ne]=size(nov);
noe=length(un);

% Evaluate exact solution

u=zeros(noe,1)+uex(xyz(:,1),xyz(:,2),xyz(:,3));

%  compute difference

err=u-un;

% ||u_ex-u_N|| with respect to discrete maximum-norm

err_inf=norm(err,inf);
if errtype~=0
    err_inf=err_inf/norm(u,inf);
end
% ||u_ex-u_N|| with respect to H1 norm

% fdq=0 LG quadrature formula with nq nodes on each element
% fdq=1 LGL quadrature formula with npdx nodes on each element

[err_h1]=normah1_3d(fdq,nq,errtype,x,wx,dx,xx,jacx,y,wy,dy,yy,jacy,...
z,wz,dz,zz,jacz,xyz,ww,nov,un,u,uex,uex_x,uex_y,uex_z);

% ||u_ex-u_N|| with respect to L2 norm

[err_l2]=normal2_3d(fdq,nq,errtype,x,wx,xx,jacx,y,wy,yy,jacy,...
z,wz,dz,zz,jacz,xyz,ww,nov,un,u,uex);

return
