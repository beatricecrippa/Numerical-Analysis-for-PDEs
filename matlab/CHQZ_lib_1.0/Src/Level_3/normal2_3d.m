function [err_l2]=normal2_3d(fdq,nq,errtype,x,wx,xx,jacx,y,wy,yy,jacy,...
z,wz,dz,zz,jacz,xyz,ww,nov,un,u,uex);
%% NORMAL2_3D   Computes L2-norm in 3D
%
%  [err_l2]=normal2_2d(fdq,nq,errtype,x,wx,xx,jacx,y,wy,yy,jacy,...
%                z,wz,zz,jacz,xyz,ww,nov,un,u,uex);
%
% Input : fdq = 0  uses Legendre Gauss quadrature formulas with nq nodes
%               in each element (exactness degree = 2*nq+1)
%             = 1  uses Legendre Gauss Lobatto quadrature formulas with npdx/y/z 
%                  quadrature nodes in each element. 
%                Quadrature nodes are the nodes of the mesh. 
%         nq = nodes (in each element and along each direction) 
%              for GL quadrature formulas. Not used if  fdq == 1
%         errtype = 0 for absolute error ||u-u_ex||
%                   1 for relative error ||u-u_ex||/||u_ex||
%         x = column array  with npdx LGL nodes in [-1,1]
%         wx= column array  with npdx LGL weigths in [-1,1]
%         dx= derivative matrix produced with derlgl
%         xx(1:8,ie)=[x_V1_ie;x_V2_ie;x_V3_ie;x_V4_ie;...
%                        x_V5_ie;x_V6_ie;x_V7_ie;x_V8_ie]
%            (ne=nex*ney is the global number of spectral elements)
%         jacx = array (length(jacx)=ne); jacx(ie)= (x_V2_ie-x_V1_ie)/2
%         y = npdy LGL nodes in [-1,1], previously generated by xwlgl
%         wy = npdy LGL weigths in [-1,1], previously generated by xwlgl
%         dy= derivative matrix produced with derlgl
%         yy = 2-indexes array of size (8,ne):
%         yy(1:8,ie)=[y_V1_ie;y_V2_ie;y_V3_ie;y_V4_ie;...
%                        y_V5_ie;y_V6_ie;y_V7_ie;y_V8_ie]
%         jacy = array (length(jacy)=ne); jacy(ie)= (y_V3_ie-y_V1_ie)/2
%         z = npdy LGL nodes in [-1,1], previously generated by xwlgl
%         wz = npdy LGL weigths in [-1,1], previously generated by xwlgl
%         dz= derivative matrix produced with derlgl
%         zz = 2-indexes array of size (8,ne):
%         zz(1:8,ie)=[z_V1_ie;z_V2_ie;z_V3_ie;z_V4_ie;...
%                        z_V5_ie;z_V6_ie;z_V7_ie;z_V8_ie]
%         jacz = array (length(jacz)=ne); jacz(ie)= (z_V5_ie-z_V1_ie)/2
%         xyz = column array with global mesh, length: noe=nov(npdx*npdy*npdz,ne)
%         ww = column array with global weigths, length: noe=nov(npdx*npdy*npdz,ne)
%              diag(ww) is the mass matrix associated to SEM discretization
%         nov = local to global map. 2-indexes array, size(nov)=[nov,ne]
%         un = column array with the numerical solution
%         u  = column array with the evaluation of exact solution
%         uex  = exact solution (uex=@(x,y,z)[uex(x,y,z)], with .*, .^, ./)
%
% Output: err_l2 = error in L2-norm
%
% Reference: CHQZ2 = C. Canuto, M.Y. Hussaini, A. Quarteroni, T.A. Zang,
%                    "Spectral Methods. Fundamentals in Single Domains"
%                    Springer Verlag, Berlin Heidelberg New York, 2006.

%   Written by Paola Gervasio
%   $Date: 2007/04/01$



npdx=length(x); npdy=length(y);npdz=length(wz);
mn=npdx*npdy;

[ldnov,ne]=size(nov); noe=nov(ldnov,ne);
num=0; den=0;
err_l2=0;

if fdq==0

% Legendre Gauss nodes and weigths

[xg,wxg] = xwlg(nq,-1,1);
yg=xg;zg=xg;
wyg=wxg;wzg=wxg;
wxyg=zeros(ldnov,1);
nq2=nq*nq;
nq3=nq2*nq;
for l=1:nq
for j=1:nq
for i=1:nq
wxyg((l-1)*nq2+(j-1)*nq+i)=wxg(i)*wyg(j)*wzg(l);
end
end
end

% Evaluation of Lagrange basis polynomials at quadrature nodes xg
%
[phix]= intlag_lgl (x,xg);
[phiy]= intlag_lgl (y,yg);
[phiz]= intlag_lgl (z,zg);

% Loop on spectral elements

for ie=1:ne
un_loc=un(nov(1:ldnov,ie));
[norma_loc1,norma_loc2]=normal2_ex_loc(errtype,nq,uex,un_loc,wxyg,...
 jacx(ie),xx(1:8,ie),xg,phix,...
 jacy(ie),yy(1:8,ie),yg,phiy,...
 jacz(ie),zz(1:8,ie),zg,phiz);
num=num+norma_loc1;
den=den+norma_loc2;
end

elseif fdq==1
    
num=sum((u-un).^2.*ww);
den=sum(u.^2.*ww);

end


if errtype==0
    err_l2=sqrt(num);
elseif errtype==1
    if abs(den)>1.d-14; err_l2=sqrt(num/den); end
end

return

function [norma_loc1,norma_loc2]=normal2_ex_loc(errtype,nq,uex,...
 un,wxyg,jacx,xx,xg,phix,...
    jacy,yy,yg,phiy,jacz,zz,zg,phiz);

% High degree Legendre Gaussian  formulas to compute H1-norm error

[nq,npdx]=size(phix);
[nq,npdy]=size(phiy);
[nq,npdz]=size(phiz);

% mapping quadrature nodes on element ie

xxg=xg*jacx+(xx(2)+xx(1))*.5;
yyg=yg*jacy+(yy(3)+yy(1))*.5;
zzg=zg*jacz+(zz(5)+zz(1))*.5;

nq2=nq*nq;nq3=nq2*nq;
for l=1:nq
for j=1:nq
for i=1:nq
    k=(l-1)*nq2+(j-1)*nq+i;
xyg(k,1:3)=[xxg(i),yyg(j),zzg(l)];
end
end
end
jac=jacx*jacy*jacz;


% evaluation of exact solution at quadrature nodes.

[U]=uex(xyg(:,1),xyg(:,2),xyg(:,3));


% evaluate numerical solution  at quadrature nodes.

un=reshape(un,npdx,npdy,npdz);
for l=1:npdz
un_z(l,:,:)=un(:,:,l);
end

for j=1:npdy
tt_z(:,:,j)=phiz*un_z(:,:,j);
end
for l=1:nq
tt(:,:,l)=tt_z(l,:,:);
end
for l=1:nq
un_i(:,:,l)=phix*(phiy*(tt(:,:,l))')';
end

un_i=un_i(:);


% compute the sum

norma_loc1=sum((U-un_i).^2.*wxyg)*jac;

if errtype==0
    norma_loc2=0;
else
    norma_loc2=sum(U.^2.*wxyg)*jac;
end

return


