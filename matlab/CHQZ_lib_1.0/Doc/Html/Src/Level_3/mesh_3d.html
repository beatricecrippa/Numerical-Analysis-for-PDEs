<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mesh_3d</title>
  <meta name="keywords" content="mesh_3d">
  <meta name="description" content="MESH3D   Uniform 3D Spectral element mesh on parallelepipedon">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">Src</a> &gt; <a href="index.html">Level_3</a> &gt; mesh_3d.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for Src/Level_3&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>mesh_3d
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MESH3D   Uniform 3D Spectral element mesh on parallelepipedon</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function[xx,yy,zz,jacx,jacy,jacz,xyz,ww,ifro,nov]=mesh3d(xa,xb,ya,yb,za,zb,nex,ney,nez,npdx,npdy,npdz,x,wx,y,wy,z,wz,gammax,gammay,gammaz); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> MESH3D   Uniform 3D Spectral element mesh on parallelepipedon

           Omega=(xa,xb) x (ya,yb) x (za,zb)

             V8  _________ V7
               /|        /|
              / |       / |
          V5 /________ /V6|
             |  |      |  |
             |V4|______|__| V3
             |  /      | /               
             | /       |/
             |/________/
           V1            V2
                      


       __________________________
       |      |      |     |     |
       |  3   |  6   |  9  | 12  |      Spectral elements
       |      |      |     |     |      ordering in a plane yz, then 
       __________________________       planes at different x follow.
       |      |      |     |     |
       |  2   |  5   |  8  | 11  |
       |      |      |     |     |
       __________________________
       |      |      |     |     |
       |  1   |  4   |  7  | 10  |
       |      |      |     |     |
       __________________________

  [xx,yy,zz,jacx,jacy,jacz,xyz,ww,ifro,nov]=mesh3d(xa,xb,ya,yb,za,zb,...
  nex,ney,nez,npdx,npdy,npdz,nov,x,wx,y,wy,z,wz,gammax,gammay,gammaz);

 Input: xa= abscissa of either vertex V1 or vertex V4
        xb= abscissa of either vertex V2 or vertex V3
        ya= ordinate of either vertex V1 or vertex V2
        yb= ordinate of either vertex V3 or vertex V4
        za= ordinate of either vertex V1 
        zb= ordinate of either vertex V5 
        nex = number of elements along x-direction
        ney = number of elements along y-direction
        nez = number of elements (equally spaced) along z-direction
        npdx = number of nodes in each element (the same in every element)
               along x-direction
        npdy = number of nodes in each element (the same in every element)
               along y-direction
        npdz = number of nodes in each element (the same in every element)
               along z-direction
        nov = local -global map, previously generated by cosnov_2d
        x = npdx LGL nodes in [-1,1], previously generated by xwlgl
        wx = npdx LGL weigths in [-1,1], previously generated by xwlgl
        y = npdy LGL nodes in [-1,1], previously generated by xwlgl
        wy = npdy LGL weigths in [-1,1], previously generated by xwlgl
        z = npdz LGL nodes in [-1,1], previously generated by xwlgl
        wz = npdz LGL weigths in [-1,1], previously generated by xwlgl
        gammax = column or row array of length nex-1. 
               If the deomposition of Omega is not
               uniform, gammax is the vector of position of interfaces between
               spectral elements along x-direction. If gammax=[], uniform
               decomposition is used.
        gammay = column or row array of length ney-1. 
               If the deomposition of Omega is not
               uniform, gammay is the vector of position of interfaces between
               spectral elements along y-direction. If gammay=[], uniform
               decomposition is used.
        gammaz = column or row array of length nez-1. 
               If the deomposition of Omega is not
               uniform, gammay is the vector of position of interfaces between
               spectral elements along z-direction. If gammay=[], uniform
               decomposition is used.

 Output: xx = 2-indexes array of size (8,ne) 
            xx(1:8,ie)=[x_V1_ie;x_V2_ie;x_V3_ie;x_V4_ie;...
                        x_V5_ie;x_V6_ie;x_V7_ie;x_V8_ie]
            (ne=nex*ney*nez is the global number of spectral elements)
            yy(1:8,ie)=[y_V1_ie;y_V2_ie;y_V3_ie;y_V4_ie;...
                        y_V5_ie;y_V6_ie;y_V7_ie;y_V8_ie]
            zz(1:8,ie)=[z_V1_ie;z_V2_ie;z_V3_ie;z_V4_ie;...
                        z_V5_ie;z_V6_ie;z_V7_ie;z_V8_ie]
         jacx = array (length(jacx)=ne); jacx(ie)= (x_V2_ie-x_V1_ie)/2
         jacy = array (length(jacy)=ne); jacy(ie)= (y_V3_ie-y_V1_ie)/2
         jacz = array (length(jacz)=ne); jacz(ie)= (z_V5_ie-z_V1_ie)/2
         xyz = column array with global mesh, length: noe=nov(npdx*npdy*npdz,ne)
         ww = column array with global weigths, length: noe=nov(npdx*npdy*npdz,ne)
              diag(ww) is the mass matrix associated to SEM discretization
         ifro = column array of length noe=nov(npdx*npdy*npdz,ne): 
            if (x_i,y_i) is internal to Omega then ifro(i)=0,
            if (x_i,y_i) is on \partial\Omega then ifro(i)=1,
         nov = 2-index array of local to global map,
               size(nov)=[max(npdx*npdy*npdz),ne]


 Reference: CHQZ2 = C. Canuto, M.Y. Hussaini, A. Quarteroni, T.A. Zang,
                    &quot;Spectral Methods. Fundamentals in Single Domains&quot;
                    Springer Verlag, Berlin Heidelberg New York, 2006.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../Src/Elliptic_3d/lap_3d.html" class="code" title="function [xyz,un,D,param]=lap_3d(xa,xb,ya,yb,za,zb,gam,uex,uex_x,uex_y,uex_z,ff,nex,nx,ney,ny,nez,nz,gammax,gammay,gammaz,param);">lap_3d</a>	LAP_3D   Numerical solution of the 3D b.v.p. -Delta u + gam u = f</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function[xx,yy,zz,jacx,jacy,jacz,xyz,ww,ifro,nov]=mesh3d(xa,xb,ya,yb,za,zb,</a><span class="keyword">...</span>
0002 nex,ney,nez,npdx,npdy,npdz,x,wx,y,wy,z,wz,gammax,gammay,gammaz);
0003 <span class="comment">% MESH3D   Uniform 3D Spectral element mesh on parallelepipedon</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%           Omega=(xa,xb) x (ya,yb) x (za,zb)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%             V8  _________ V7</span>
0008 <span class="comment">%               /|        /|</span>
0009 <span class="comment">%              / |       / |</span>
0010 <span class="comment">%          V5 /________ /V6|</span>
0011 <span class="comment">%             |  |      |  |</span>
0012 <span class="comment">%             |V4|______|__| V3</span>
0013 <span class="comment">%             |  /      | /</span>
0014 <span class="comment">%             | /       |/</span>
0015 <span class="comment">%             |/________/</span>
0016 <span class="comment">%           V1            V2</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%</span>
0020 <span class="comment">%       __________________________</span>
0021 <span class="comment">%       |      |      |     |     |</span>
0022 <span class="comment">%       |  3   |  6   |  9  | 12  |      Spectral elements</span>
0023 <span class="comment">%       |      |      |     |     |      ordering in a plane yz, then</span>
0024 <span class="comment">%       __________________________       planes at different x follow.</span>
0025 <span class="comment">%       |      |      |     |     |</span>
0026 <span class="comment">%       |  2   |  5   |  8  | 11  |</span>
0027 <span class="comment">%       |      |      |     |     |</span>
0028 <span class="comment">%       __________________________</span>
0029 <span class="comment">%       |      |      |     |     |</span>
0030 <span class="comment">%       |  1   |  4   |  7  | 10  |</span>
0031 <span class="comment">%       |      |      |     |     |</span>
0032 <span class="comment">%       __________________________</span>
0033 <span class="comment">%</span>
0034 <span class="comment">%  [xx,yy,zz,jacx,jacy,jacz,xyz,ww,ifro,nov]=mesh3d(xa,xb,ya,yb,za,zb,...</span>
0035 <span class="comment">%  nex,ney,nez,npdx,npdy,npdz,nov,x,wx,y,wy,z,wz,gammax,gammay,gammaz);</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% Input: xa= abscissa of either vertex V1 or vertex V4</span>
0038 <span class="comment">%        xb= abscissa of either vertex V2 or vertex V3</span>
0039 <span class="comment">%        ya= ordinate of either vertex V1 or vertex V2</span>
0040 <span class="comment">%        yb= ordinate of either vertex V3 or vertex V4</span>
0041 <span class="comment">%        za= ordinate of either vertex V1</span>
0042 <span class="comment">%        zb= ordinate of either vertex V5</span>
0043 <span class="comment">%        nex = number of elements along x-direction</span>
0044 <span class="comment">%        ney = number of elements along y-direction</span>
0045 <span class="comment">%        nez = number of elements (equally spaced) along z-direction</span>
0046 <span class="comment">%        npdx = number of nodes in each element (the same in every element)</span>
0047 <span class="comment">%               along x-direction</span>
0048 <span class="comment">%        npdy = number of nodes in each element (the same in every element)</span>
0049 <span class="comment">%               along y-direction</span>
0050 <span class="comment">%        npdz = number of nodes in each element (the same in every element)</span>
0051 <span class="comment">%               along z-direction</span>
0052 <span class="comment">%        nov = local -global map, previously generated by cosnov_2d</span>
0053 <span class="comment">%        x = npdx LGL nodes in [-1,1], previously generated by xwlgl</span>
0054 <span class="comment">%        wx = npdx LGL weigths in [-1,1], previously generated by xwlgl</span>
0055 <span class="comment">%        y = npdy LGL nodes in [-1,1], previously generated by xwlgl</span>
0056 <span class="comment">%        wy = npdy LGL weigths in [-1,1], previously generated by xwlgl</span>
0057 <span class="comment">%        z = npdz LGL nodes in [-1,1], previously generated by xwlgl</span>
0058 <span class="comment">%        wz = npdz LGL weigths in [-1,1], previously generated by xwlgl</span>
0059 <span class="comment">%        gammax = column or row array of length nex-1.</span>
0060 <span class="comment">%               If the deomposition of Omega is not</span>
0061 <span class="comment">%               uniform, gammax is the vector of position of interfaces between</span>
0062 <span class="comment">%               spectral elements along x-direction. If gammax=[], uniform</span>
0063 <span class="comment">%               decomposition is used.</span>
0064 <span class="comment">%        gammay = column or row array of length ney-1.</span>
0065 <span class="comment">%               If the deomposition of Omega is not</span>
0066 <span class="comment">%               uniform, gammay is the vector of position of interfaces between</span>
0067 <span class="comment">%               spectral elements along y-direction. If gammay=[], uniform</span>
0068 <span class="comment">%               decomposition is used.</span>
0069 <span class="comment">%        gammaz = column or row array of length nez-1.</span>
0070 <span class="comment">%               If the deomposition of Omega is not</span>
0071 <span class="comment">%               uniform, gammay is the vector of position of interfaces between</span>
0072 <span class="comment">%               spectral elements along z-direction. If gammay=[], uniform</span>
0073 <span class="comment">%               decomposition is used.</span>
0074 <span class="comment">%</span>
0075 <span class="comment">% Output: xx = 2-indexes array of size (8,ne)</span>
0076 <span class="comment">%            xx(1:8,ie)=[x_V1_ie;x_V2_ie;x_V3_ie;x_V4_ie;...</span>
0077 <span class="comment">%                        x_V5_ie;x_V6_ie;x_V7_ie;x_V8_ie]</span>
0078 <span class="comment">%            (ne=nex*ney*nez is the global number of spectral elements)</span>
0079 <span class="comment">%            yy(1:8,ie)=[y_V1_ie;y_V2_ie;y_V3_ie;y_V4_ie;...</span>
0080 <span class="comment">%                        y_V5_ie;y_V6_ie;y_V7_ie;y_V8_ie]</span>
0081 <span class="comment">%            zz(1:8,ie)=[z_V1_ie;z_V2_ie;z_V3_ie;z_V4_ie;...</span>
0082 <span class="comment">%                        z_V5_ie;z_V6_ie;z_V7_ie;z_V8_ie]</span>
0083 <span class="comment">%         jacx = array (length(jacx)=ne); jacx(ie)= (x_V2_ie-x_V1_ie)/2</span>
0084 <span class="comment">%         jacy = array (length(jacy)=ne); jacy(ie)= (y_V3_ie-y_V1_ie)/2</span>
0085 <span class="comment">%         jacz = array (length(jacz)=ne); jacz(ie)= (z_V5_ie-z_V1_ie)/2</span>
0086 <span class="comment">%         xyz = column array with global mesh, length: noe=nov(npdx*npdy*npdz,ne)</span>
0087 <span class="comment">%         ww = column array with global weigths, length: noe=nov(npdx*npdy*npdz,ne)</span>
0088 <span class="comment">%              diag(ww) is the mass matrix associated to SEM discretization</span>
0089 <span class="comment">%         ifro = column array of length noe=nov(npdx*npdy*npdz,ne):</span>
0090 <span class="comment">%            if (x_i,y_i) is internal to Omega then ifro(i)=0,</span>
0091 <span class="comment">%            if (x_i,y_i) is on \partial\Omega then ifro(i)=1,</span>
0092 <span class="comment">%         nov = 2-index array of local to global map,</span>
0093 <span class="comment">%               size(nov)=[max(npdx*npdy*npdz),ne]</span>
0094 <span class="comment">%</span>
0095 <span class="comment">%</span>
0096 <span class="comment">% Reference: CHQZ2 = C. Canuto, M.Y. Hussaini, A. Quarteroni, T.A. Zang,</span>
0097 <span class="comment">%                    &quot;Spectral Methods. Fundamentals in Single Domains&quot;</span>
0098 <span class="comment">%                    Springer Verlag, Berlin Heidelberg New York, 2006.</span>
0099 
0100 <span class="comment">%   Written by Paola Gervasio</span>
0101 <span class="comment">%   $Date: 2007/04/01$</span>
0102 
0103 mn=npdx*npdy; ldnov=mn*npdz; ne=nex*ney*nez;
0104 xx=zeros(8,ne); yy=zeros(8,ne); zz=zeros(8,ne);
0105 jac=zeros(ne,1);
0106 jacx=zeros(ne,1);
0107 jacy=zeros(ne,1);
0108 jacz=zeros(ne,1);
0109 <span class="keyword">if</span> sum(size(gammax))==0 
0110     Hx=(xb-xa)/nex*ones(nex);
0111 <span class="keyword">else</span> 
0112     Hx=zeros(nex,1);
0113     Hx(1)=gammax(1)-xa;
0114     Hx(2:nex-1)=gammax(2:nex-1)-gammax(1:nex-2);
0115     Hx(nex)=xb-gammax(nex-1);
0116 <span class="keyword">end</span>
0117 <span class="keyword">if</span> sum(size(gammay))==0 
0118     Hy=(yb-ya)/ney*ones(ney);
0119 <span class="keyword">else</span> 
0120     Hy=zeros(ney,1);
0121     Hy(1)=gammay(1)-ya;
0122     Hy(2:ney-1)=gammay(2:ney-1)-gammay(1:ney-2);
0123     Hy(ney)=yb-gammay(ney-1);
0124 <span class="keyword">end</span>
0125 <span class="keyword">if</span> sum(size(gammaz))==0 
0126     Hz=(zb-za)/nez*ones(nez);
0127 <span class="keyword">else</span> 
0128     Hz=zeros(nez,1);
0129     Hz(1)=gammaz(1)-za;
0130     Hz(2:nez-1)=gammaz(2:nez-1)-gammaz(1:nez-2);
0131     Hz(nez)=zb-gammaz(nez-1);
0132 <span class="keyword">end</span>
0133 
0134 <span class="comment">% construction of xx, yy, zz, jacx, jacy, jacz</span>
0135 
0136 
0137 <span class="comment">% first element</span>
0138       xx(1:4,1)=[xa;xa+Hx(1);xa+Hx(1);xa];
0139       xx(5:8,1)=xx(1:4,1);
0140       yy(1:2,1)=[ya,ya]; yy(3:4,1)=yy(1:2,1)+Hy(1);
0141       yy(5:6,1)=yy(1:2,1);yy(7:8,1)=yy(3:4,1);
0142       zz(1:4,1)=[za;za;za;za];
0143       zz(5:8,1)=[za+Hz(1);za+Hz(1);za+Hz(1);za+Hz(1)];
0144       jacx(1)=Hx(1)*.5;jacy(1)=Hy(1)*.5; jacz(1)=Hz(1)*.5;
0145       
0146 <span class="comment">% first row of elements along y-direction</span>
0147 <span class="keyword">for</span> iey=2:ney
0148       ie=iey;
0149       xx(1:8,ie)=xx(1:8,1);
0150       yy(1:2,ie)=yy(3:4,iey-1); yy(3:4,ie)=yy(1:2,ie)+Hy(iey);
0151       yy(5:6,ie)=yy(1:2,ie);yy(7:8,ie)=yy(3:4,ie);
0152       zz(1:4,ie)=zz(1:4,1); zz(5:8,ie)=zz(1:4,ie)+Hz(1);
0153 jacx(ie)=Hx(1)*.5;
0154 jacy(ie)=Hy(iey)*.5;
0155 jacz(ie)=Hz(1)*.5;
0156 <span class="keyword">end</span>
0157       
0158 <span class="comment">% other elements on the plane xz</span>
0159 
0160 <span class="keyword">for</span> iez=2:nez
0161 <span class="keyword">for</span> iey=1:ney
0162       ie=(iez-1)*ney+iey;
0163 
0164       xx(1:8,ie)=xx(1:8,1);
0165       yy(1:8,ie)=yy(1:8,iey);
0166       zz(1:4,ie)=zz(5:8,ie-ney); zz(5:8,ie)=zz(1:4,ie)+Hz(iez);
0167 jacx(ie)=Hx(1)*.5;
0168 jacy(ie)=Hy(iey)*.5;
0169 jacz(ie)=Hz(iez)*.5;
0170 <span class="keyword">end</span>
0171 <span class="keyword">end</span>
0172 
0173 <span class="comment">% the whole mesh</span>
0174 
0175 ne2=ney*nez;
0176 <span class="keyword">for</span> iex=2:nex
0177 <span class="keyword">for</span> iez=1:nez
0178 <span class="keyword">for</span> iey=1:ney
0179       ie=(iex-1)*ne2+(iez-1)*ney+iey;
0180       xx([1;4;5;8],ie)=xx([2;3;6;7],ie-ne2);
0181       xx([2;3;6;7],ie)=xx([1;4;5;8],ie)+Hx(iex);
0182       yy(1:8,ie)=yy(1:8,iey);
0183       zz(1:8,ie)=zz(1:8,ie-ne2);
0184 jacx(ie)=Hx(iex)*.5; 
0185 jacy(ie)=Hy(iey)*.5; 
0186 jacz(ie)=Hz(iez)*.5;
0187 <span class="keyword">end</span>
0188 <span class="keyword">end</span>
0189 <span class="keyword">end</span>
0190 
0191 <span class="comment">% construction of all local meshes</span>
0192 
0193 xyz_loc=zeros(ldnov,3,ne);
0194 ifro_loc=zeros(ldnov,ne);
0195 ww_loc=zeros(ldnov,ne);
0196 <span class="keyword">for</span> ie=1:ne
0197 bpa=(xx(1,ie)+xx(2,ie))*.5; 
0198 dpc=(yy(1,ie)+yy(3,ie))*.5; 
0199 epf=(zz(1,ie)+zz(5,ie))*.5;
0200 jac=jacx(ie)*jacy(ie)*jacz(ie);
0201 <span class="keyword">for</span> l=1:npdz
0202 <span class="keyword">for</span> j=1:npdy
0203 <span class="keyword">for</span> i=1:npdx
0204 k=(l-1)*mn+(j-1)*npdx+i;
0205       xyz_loc(k,1,ie)=x(i)*jacx(ie)+bpa;
0206       xyz_loc(k,2,ie)=y(j)*jacy(ie)+dpc;
0207       xyz_loc(k,3,ie)=z(l)*jacz(ie)+epf;
0208 ww_loc(k,ie)=wz(l)*wx(i)*wy(j)*jac; 
0209 <span class="keyword">end</span>
0210 <span class="keyword">end</span>
0211 
0212 <span class="keyword">end</span>
0213 
0214 <span class="keyword">for</span> l=1:npdz
0215 <span class="keyword">for</span> j=1:npdy
0216 <span class="keyword">for</span> i=1:npdx
0217   k=(l-1)*mn+(j-1)*npdx+i;
0218   <span class="keyword">if</span> (l==1 | l==npdz | j==1 | j==npdy | i==1  | i==npdx)
0219   ifro_loc(k,ie)=1;
0220   <span class="keyword">end</span>
0221 <span class="keyword">end</span>
0222 <span class="keyword">end</span>
0223 <span class="keyword">end</span>
0224 
0225 <span class="keyword">end</span>
0226 
0227 
0228 <span class="comment">% assembling global and unique mesh</span>
0229 xyz=zeros(ldnov*ne,3); 
0230 nov=zeros(ldnov,ne);
0231 xyz(1:ldnov,1:3)=xyz_loc(1:ldnov,1:3,1);
0232 nov(1:ldnov,1)=(1:ldnov)';
0233 ifro(1:ldnov)=ifro_loc(1:ldnov,1);
0234 epsi=1.e-14;
0235 last=ldnov;
0236 <span class="keyword">for</span> ie=2:ne
0237 <span class="keyword">for</span> i=1:ldnov
0238 punto_new(1:3)=xyz_loc(i,1:3,ie);
0239 
0240 tt=0;j=1;
0241 <span class="keyword">while</span> (j&lt;=last &amp; tt==0)
0242 <span class="keyword">if</span> (ifro(j)~=0)
0243 
0244 dd=abs(punto_new-xyz(j,1:3));
0245 <span class="keyword">if</span> (dd&lt;=epsi)
0246 nov(i,ie)=j;
0247 tt=1;
0248 <span class="keyword">end</span>
0249 <span class="keyword">end</span>
0250 j=j+1;
0251 <span class="keyword">end</span>
0252 <span class="keyword">if</span> (nov(i,ie)==0)
0253 last=last+1;
0254 xyz(last,1:3)=punto_new(1:3);
0255 ifro(last)=ifro_loc(i,ie);
0256 nov(i,ie)=last;
0257 <span class="keyword">end</span>
0258 
0259 <span class="keyword">end</span>
0260 <span class="keyword">end</span>
0261 
0262 ifro=ifro';
0263 noe=last;
0264 xyz=xyz(1:noe,1:3);
0265 ww=zeros(noe,1);
0266 
0267 <span class="keyword">for</span> ie=1:ne
0268     ww(nov(1:ldnov,ie))=ww(nov(1:ldnov,ie))+ww_loc(1:ldnov,ie);
0269 <span class="keyword">end</span>
0270 clear ww_loc xyz_loc ifro_loc
0271 
0272 <span class="keyword">for</span> i=1:noe
0273       <span class="keyword">if</span> (ifro(i)~=0)
0274       <span class="keyword">if</span>((abs(xyz(i,1)-xa) &gt; eps &amp; abs(xyz(i,1)-xb) &gt; eps)<span class="keyword">...</span>
0275      &amp; (abs(xyz(i,2)-ya) &gt; eps &amp; abs(xyz(i,2)-yb) &gt; eps)<span class="keyword">...</span>
0276      &amp; (abs(xyz(i,3)-za) &gt; eps &amp; abs(xyz(i,3)-zb) &gt; eps))
0277       ifro(i)=0;
0278       <span class="keyword">end</span>
0279       <span class="keyword">end</span>
0280 <span class="keyword">end</span>
0281 
0282</pre></div>
<hr><address>Generated on Fri 21-Sep-2007 10:07:00 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>